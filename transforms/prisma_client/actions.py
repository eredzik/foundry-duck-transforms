# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class datasetActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.dataset]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await dataset.prisma().query_raw(
            'SELECT * FROM dataset WHERE id = ?',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.dataset
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await dataset.prisma().query_first(
            'SELECT * FROM dataset WHERE rid = ?',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.datasetCreateInput,
        include: Optional[types.datasetInclude] = None
    ) -> _PrismaModelT:
        """Create a new dataset record.

        Parameters
        ----------
        data
            dataset record data
        include
            Specifies which relations should be loaded on the returned dataset model

        Returns
        -------
        prisma.models.dataset
            The created dataset record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a dataset record from just the required fields
        dataset = await dataset.prisma().create(
            data={
                # data to create a dataset record
                'rid': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.datasetCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple dataset records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of dataset record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await dataset.prisma().create_many(
            data=[
                {
                    # data to create a dataset record
                    'rid': 'bbehjachib',
                },
                {
                    # data to create a dataset record
                    'rid': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.datasetWhereUniqueInput,
        include: Optional[types.datasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single dataset record.

        Parameters
        ----------
        where
            dataset filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned dataset model

        Returns
        -------
        prisma.models.dataset
            The deleted dataset record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset = await dataset.prisma().delete(
            where={
                'id': 368800899,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.datasetWhereUniqueInput,
        include: Optional[types.datasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique dataset record.

        Parameters
        ----------
        where
            dataset filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned dataset model

        Returns
        -------
        prisma.models.dataset
            The found dataset record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset = await dataset.prisma().find_unique(
            where={
                'id': 1508029952,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.datasetWhereUniqueInput,
        include: Optional[types.datasetInclude] = None
    ) -> _PrismaModelT:
        """Find a unique dataset record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            dataset filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned dataset model

        Returns
        -------
        prisma.models.dataset
            The found dataset record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset = await dataset.prisma().find_unique_or_raise(
            where={
                'id': 486256185,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.datasetWhereInput] = None,
        cursor: Optional[types.datasetWhereUniqueInput] = None,
        include: Optional[types.datasetInclude] = None,
        order: Optional[Union[types.datasetOrderByInput, List[types.datasetOrderByInput]]] = None,
        distinct: Optional[List[types.datasetScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple dataset records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of dataset records returned
        skip
            Ignore the first N results
        where
            dataset filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset model
        order
            Order the returned dataset records by any field
        distinct
            Filter dataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.dataset]
            The list of all dataset records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 dataset records
        datasets = await dataset.prisma().find_many(take=10)

        # find the first 5 dataset records ordered by the id field
        datasets = await dataset.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.datasetWhereInput] = None,
        cursor: Optional[types.datasetWhereUniqueInput] = None,
        include: Optional[types.datasetInclude] = None,
        order: Optional[Union[types.datasetOrderByInput, List[types.datasetOrderByInput]]] = None,
        distinct: Optional[List[types.datasetScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single dataset record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            dataset filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset model
        order
            Order the returned dataset records by any field
        distinct
            Filter dataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.dataset
            The first dataset record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second dataset record ordered by the rid field
        dataset = await dataset.prisma().find_first(
            skip=1,
            order={
                'rid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.datasetWhereInput] = None,
        cursor: Optional[types.datasetWhereUniqueInput] = None,
        include: Optional[types.datasetInclude] = None,
        order: Optional[Union[types.datasetOrderByInput, List[types.datasetOrderByInput]]] = None,
        distinct: Optional[List[types.datasetScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single dataset record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            dataset filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset model
        order
            Order the returned dataset records by any field
        distinct
            Filter dataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.dataset
            The first dataset record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second dataset record ordered by the id field
        dataset = await dataset.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.datasetUpdateInput,
        where: types.datasetWhereUniqueInput,
        include: Optional[types.datasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single dataset record.

        Parameters
        ----------
        data
            dataset record data specifying what to update
        where
            dataset filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned dataset model

        Returns
        -------
        prisma.models.dataset
            The updated dataset record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        dataset = await dataset.prisma().update(
            where={
                'id': 1062517886,
            },
            data={
                # data to update the dataset record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.datasetWhereUniqueInput,
        data: types.datasetUpsertInput,
        include: Optional[types.datasetInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            dataset filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned dataset model

        Returns
        -------
        prisma.models.dataset
            The created or updated dataset record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset = await dataset.prisma().upsert(
            where={
                'id': 267834847,
            },
            data={
                'create': {
                    'id': 267834847,
                    'rid': 'cadfabfehe',
                },
                'update': {
                    'rid': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.datasetUpdateManyMutationInput,
        where: types.datasetWhereInput,
    ) -> int:
        """Update multiple dataset records

        Parameters
        ----------
        data
            dataset data to update the selected dataset records to
        where
            Filter to select the dataset records to update

        Returns
        -------
        int
            The total number of dataset records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all dataset records
        total = await dataset.prisma().update_many(
            data={
                'rid': 'biabhbdai'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.datasetWhereInput] = None,
        cursor: Optional[types.datasetWhereUniqueInput] = None,
    ) -> int:
        """Count the number of dataset records present in the database

        Parameters
        ----------
        select
            Select the dataset fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            dataset filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.datasetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await dataset.prisma().count()

        # results: prisma.types.datasetCountAggregateOutput
        results = await dataset.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.datasetCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.datasetWhereInput] = None,
        cursor: Optional[types.datasetWhereUniqueInput] = None,
    ) -> types.datasetCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.datasetCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.datasetWhereInput] = None,
        cursor: Optional[types.datasetWhereUniqueInput] = None,
    ) -> Union[int, types.datasetCountAggregateOutput]:
        """Count the number of dataset records present in the database

        Parameters
        ----------
        select
            Select the dataset fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            dataset filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.datasetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await dataset.prisma().count()

        # results: prisma.types.datasetCountAggregateOutput
        results = await dataset.prisma().count(
            select={
                '_all': True,
                'rid': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.datasetCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.datasetWhereInput] = None
    ) -> int:
        """Delete multiple dataset records.

        Parameters
        ----------
        where
            Optional dataset filter to find the records to be deleted

        Returns
        -------
        int
            The total number of dataset records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all dataset records
        total = await dataset.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.datasetScalarFieldKeysT'],
        *,
        where: Optional['types.datasetWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.datasetAvgAggregateInput'] = None,
        sum: Optional['types.datasetSumAggregateInput'] = None,
        min: Optional['types.datasetMinAggregateInput'] = None,
        max: Optional['types.datasetMaxAggregateInput'] = None,
        having: Optional['types.datasetScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.datasetCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.datasetScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.datasetScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.datasetGroupByOutput']:
        """Group dataset records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar dataset fields to group records by
        where
            dataset filter to select records
        take
            Limit the maximum number of dataset records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.datasetGroupByOutput]
            A list of dictionaries representing the dataset record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group dataset records by id values
        # and count how many records are in each group
        results = await dataset.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class dataset_identifierActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.dataset_identifier]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await dataset_identifier.prisma().query_raw(
            'SELECT * FROM dataset_identifier WHERE id = ?',
            836760821,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.dataset_identifier
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await dataset_identifier.prisma().query_first(
            'SELECT * FROM dataset_identifier WHERE rid_or_path = ?',
            'fjfddhigg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.dataset_identifierCreateInput,
        include: Optional[types.dataset_identifierInclude] = None
    ) -> _PrismaModelT:
        """Create a new dataset_identifier record.

        Parameters
        ----------
        data
            dataset_identifier record data
        include
            Specifies which relations should be loaded on the returned dataset_identifier model

        Returns
        -------
        prisma.models.dataset_identifier
            The created dataset_identifier record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a dataset_identifier record from just the required fields
        dataset_identifier = await dataset_identifier.prisma().create(
            data={
                # data to create a dataset_identifier record
                'rid_or_path': 'hjaecfifb',
                'datasetid': 2111915288,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.dataset_identifierCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple dataset_identifier records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of dataset_identifier record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await dataset_identifier.prisma().create_many(
            data=[
                {
                    # data to create a dataset_identifier record
                    'rid_or_path': 'bbejhfidcb',
                    'datasetid': 1644289366,
                },
                {
                    # data to create a dataset_identifier record
                    'rid_or_path': 'bdiicjafbj',
                    'datasetid': 1647418052,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.dataset_identifierWhereUniqueInput,
        include: Optional[types.dataset_identifierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single dataset_identifier record.

        Parameters
        ----------
        where
            dataset_identifier filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned dataset_identifier model

        Returns
        -------
        prisma.models.dataset_identifier
            The deleted dataset_identifier record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset_identifier = await dataset_identifier.prisma().delete(
            where={
                'id': 1675546029,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.dataset_identifierWhereUniqueInput,
        include: Optional[types.dataset_identifierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique dataset_identifier record.

        Parameters
        ----------
        where
            dataset_identifier filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned dataset_identifier model

        Returns
        -------
        prisma.models.dataset_identifier
            The found dataset_identifier record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset_identifier = await dataset_identifier.prisma().find_unique(
            where={
                'id': 1767274722,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.dataset_identifierWhereUniqueInput,
        include: Optional[types.dataset_identifierInclude] = None
    ) -> _PrismaModelT:
        """Find a unique dataset_identifier record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            dataset_identifier filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned dataset_identifier model

        Returns
        -------
        prisma.models.dataset_identifier
            The found dataset_identifier record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset_identifier = await dataset_identifier.prisma().find_unique_or_raise(
            where={
                'id': 326272115,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.dataset_identifierWhereInput] = None,
        cursor: Optional[types.dataset_identifierWhereUniqueInput] = None,
        include: Optional[types.dataset_identifierInclude] = None,
        order: Optional[Union[types.dataset_identifierOrderByInput, List[types.dataset_identifierOrderByInput]]] = None,
        distinct: Optional[List[types.dataset_identifierScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple dataset_identifier records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of dataset_identifier records returned
        skip
            Ignore the first N results
        where
            dataset_identifier filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset_identifier model
        order
            Order the returned dataset_identifier records by any field
        distinct
            Filter dataset_identifier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.dataset_identifier]
            The list of all dataset_identifier records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 dataset_identifier records
        dataset_identifiers = await dataset_identifier.prisma().find_many(take=10)

        # find the first 5 dataset_identifier records ordered by the datasetid field
        dataset_identifiers = await dataset_identifier.prisma().find_many(
            take=5,
            order={
                'datasetid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.dataset_identifierWhereInput] = None,
        cursor: Optional[types.dataset_identifierWhereUniqueInput] = None,
        include: Optional[types.dataset_identifierInclude] = None,
        order: Optional[Union[types.dataset_identifierOrderByInput, List[types.dataset_identifierOrderByInput]]] = None,
        distinct: Optional[List[types.dataset_identifierScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single dataset_identifier record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            dataset_identifier filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset_identifier model
        order
            Order the returned dataset_identifier records by any field
        distinct
            Filter dataset_identifier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.dataset_identifier
            The first dataset_identifier record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second dataset_identifier record ordered by the id field
        dataset_identifier = await dataset_identifier.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.dataset_identifierWhereInput] = None,
        cursor: Optional[types.dataset_identifierWhereUniqueInput] = None,
        include: Optional[types.dataset_identifierInclude] = None,
        order: Optional[Union[types.dataset_identifierOrderByInput, List[types.dataset_identifierOrderByInput]]] = None,
        distinct: Optional[List[types.dataset_identifierScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single dataset_identifier record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            dataset_identifier filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset_identifier model
        order
            Order the returned dataset_identifier records by any field
        distinct
            Filter dataset_identifier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.dataset_identifier
            The first dataset_identifier record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second dataset_identifier record ordered by the rid_or_path field
        dataset_identifier = await dataset_identifier.prisma().find_first_or_raise(
            skip=1,
            order={
                'rid_or_path': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.dataset_identifierUpdateInput,
        where: types.dataset_identifierWhereUniqueInput,
        include: Optional[types.dataset_identifierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single dataset_identifier record.

        Parameters
        ----------
        data
            dataset_identifier record data specifying what to update
        where
            dataset_identifier filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned dataset_identifier model

        Returns
        -------
        prisma.models.dataset_identifier
            The updated dataset_identifier record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        dataset_identifier = await dataset_identifier.prisma().update(
            where={
                'id': 1343201072,
            },
            data={
                # data to update the dataset_identifier record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.dataset_identifierWhereUniqueInput,
        data: types.dataset_identifierUpsertInput,
        include: Optional[types.dataset_identifierInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            dataset_identifier filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned dataset_identifier model

        Returns
        -------
        prisma.models.dataset_identifier
            The created or updated dataset_identifier record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset_identifier = await dataset_identifier.prisma().upsert(
            where={
                'id': 675780521,
            },
            data={
                'create': {
                    'id': 675780521,
                    'rid_or_path': 'bdiicjafbj',
                    'datasetid': 1647418052,
                },
                'update': {
                    'rid_or_path': 'bdiicjafbj',
                    'datasetid': 1647418052,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.dataset_identifierUpdateManyMutationInput,
        where: types.dataset_identifierWhereInput,
    ) -> int:
        """Update multiple dataset_identifier records

        Parameters
        ----------
        data
            dataset_identifier data to update the selected dataset_identifier records to
        where
            Filter to select the dataset_identifier records to update

        Returns
        -------
        int
            The total number of dataset_identifier records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all dataset_identifier records
        total = await dataset_identifier.prisma().update_many(
            data={
                'datasetid': 744964398
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.dataset_identifierWhereInput] = None,
        cursor: Optional[types.dataset_identifierWhereUniqueInput] = None,
    ) -> int:
        """Count the number of dataset_identifier records present in the database

        Parameters
        ----------
        select
            Select the dataset_identifier fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            dataset_identifier filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.dataset_identifierCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await dataset_identifier.prisma().count()

        # results: prisma.types.dataset_identifierCountAggregateOutput
        results = await dataset_identifier.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.dataset_identifierCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.dataset_identifierWhereInput] = None,
        cursor: Optional[types.dataset_identifierWhereUniqueInput] = None,
    ) -> types.dataset_identifierCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.dataset_identifierCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.dataset_identifierWhereInput] = None,
        cursor: Optional[types.dataset_identifierWhereUniqueInput] = None,
    ) -> Union[int, types.dataset_identifierCountAggregateOutput]:
        """Count the number of dataset_identifier records present in the database

        Parameters
        ----------
        select
            Select the dataset_identifier fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            dataset_identifier filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.dataset_identifierCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await dataset_identifier.prisma().count()

        # results: prisma.types.dataset_identifierCountAggregateOutput
        results = await dataset_identifier.prisma().count(
            select={
                '_all': True,
                'rid_or_path': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.dataset_identifierCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.dataset_identifierWhereInput] = None
    ) -> int:
        """Delete multiple dataset_identifier records.

        Parameters
        ----------
        where
            Optional dataset_identifier filter to find the records to be deleted

        Returns
        -------
        int
            The total number of dataset_identifier records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all dataset_identifier records
        total = await dataset_identifier.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.dataset_identifierScalarFieldKeysT'],
        *,
        where: Optional['types.dataset_identifierWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.dataset_identifierAvgAggregateInput'] = None,
        sum: Optional['types.dataset_identifierSumAggregateInput'] = None,
        min: Optional['types.dataset_identifierMinAggregateInput'] = None,
        max: Optional['types.dataset_identifierMaxAggregateInput'] = None,
        having: Optional['types.dataset_identifierScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.dataset_identifierCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.dataset_identifierScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.dataset_identifierScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.dataset_identifierGroupByOutput']:
        """Group dataset_identifier records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar dataset_identifier fields to group records by
        where
            dataset_identifier filter to select records
        take
            Limit the maximum number of dataset_identifier records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.dataset_identifierGroupByOutput]
            A list of dictionaries representing the dataset_identifier record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group dataset_identifier records by datasetid values
        # and count how many records are in each group
        results = await dataset_identifier.prisma().group_by(
            ['datasetid'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class dataset_versionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.dataset_version]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await dataset_version.prisma().query_raw(
            'SELECT * FROM dataset_version WHERE id = ?',
            1969681615,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.dataset_version
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await dataset_version.prisma().query_first(
            'SELECT * FROM dataset_version WHERE data_identity_id = ?',
            'bbbgbhfjge',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.dataset_versionCreateInput,
        include: Optional[types.dataset_versionInclude] = None
    ) -> _PrismaModelT:
        """Create a new dataset_version record.

        Parameters
        ----------
        data
            dataset_version record data
        include
            Specifies which relations should be loaded on the returned dataset_version model

        Returns
        -------
        prisma.models.dataset_version
            The created dataset_version record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a dataset_version record from just the required fields
        dataset_version = await dataset_version.prisma().create(
            data={
                # data to create a dataset_version record
                'data_identity_id': 'igbehcbab',
                'datasetId': 1303003706,
                'data_branchId': 1686638315,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.dataset_versionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple dataset_version records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of dataset_version record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await dataset_version.prisma().create_many(
            data=[
                {
                    # data to create a dataset_version record
                    'data_identity_id': 'caaaedabfc',
                    'datasetId': 1868141281,
                    'data_branchId': 1860847622,
                },
                {
                    # data to create a dataset_version record
                    'data_identity_id': 'beeifcbebf',
                    'datasetId': 1628650740,
                    'data_branchId': 1249606685,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.dataset_versionWhereUniqueInput,
        include: Optional[types.dataset_versionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single dataset_version record.

        Parameters
        ----------
        where
            dataset_version filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned dataset_version model

        Returns
        -------
        prisma.models.dataset_version
            The deleted dataset_version record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset_version = await dataset_version.prisma().delete(
            where={
                'id': 835903122,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.dataset_versionWhereUniqueInput,
        include: Optional[types.dataset_versionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique dataset_version record.

        Parameters
        ----------
        where
            dataset_version filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned dataset_version model

        Returns
        -------
        prisma.models.dataset_version
            The found dataset_version record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset_version = await dataset_version.prisma().find_unique(
            where={
                'id': 763719779,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.dataset_versionWhereUniqueInput,
        include: Optional[types.dataset_versionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique dataset_version record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            dataset_version filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned dataset_version model

        Returns
        -------
        prisma.models.dataset_version
            The found dataset_version record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset_version = await dataset_version.prisma().find_unique_or_raise(
            where={
                'id': 429995104,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.dataset_versionWhereInput] = None,
        cursor: Optional[types.dataset_versionWhereUniqueInput] = None,
        include: Optional[types.dataset_versionInclude] = None,
        order: Optional[Union[types.dataset_versionOrderByInput, List[types.dataset_versionOrderByInput]]] = None,
        distinct: Optional[List[types.dataset_versionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple dataset_version records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of dataset_version records returned
        skip
            Ignore the first N results
        where
            dataset_version filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset_version model
        order
            Order the returned dataset_version records by any field
        distinct
            Filter dataset_version records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.dataset_version]
            The list of all dataset_version records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 dataset_version records
        dataset_versions = await dataset_version.prisma().find_many(take=10)

        # find the first 5 dataset_version records ordered by the data_identity_date field
        dataset_versions = await dataset_version.prisma().find_many(
            take=5,
            order={
                'data_identity_date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.dataset_versionWhereInput] = None,
        cursor: Optional[types.dataset_versionWhereUniqueInput] = None,
        include: Optional[types.dataset_versionInclude] = None,
        order: Optional[Union[types.dataset_versionOrderByInput, List[types.dataset_versionOrderByInput]]] = None,
        distinct: Optional[List[types.dataset_versionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single dataset_version record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            dataset_version filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset_version model
        order
            Order the returned dataset_version records by any field
        distinct
            Filter dataset_version records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.dataset_version
            The first dataset_version record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second dataset_version record ordered by the datasetId field
        dataset_version = await dataset_version.prisma().find_first(
            skip=1,
            order={
                'datasetId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.dataset_versionWhereInput] = None,
        cursor: Optional[types.dataset_versionWhereUniqueInput] = None,
        include: Optional[types.dataset_versionInclude] = None,
        order: Optional[Union[types.dataset_versionOrderByInput, List[types.dataset_versionOrderByInput]]] = None,
        distinct: Optional[List[types.dataset_versionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single dataset_version record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            dataset_version filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned dataset_version model
        order
            Order the returned dataset_version records by any field
        distinct
            Filter dataset_version records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.dataset_version
            The first dataset_version record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second dataset_version record ordered by the data_branchId field
        dataset_version = await dataset_version.prisma().find_first_or_raise(
            skip=1,
            order={
                'data_branchId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.dataset_versionUpdateInput,
        where: types.dataset_versionWhereUniqueInput,
        include: Optional[types.dataset_versionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single dataset_version record.

        Parameters
        ----------
        data
            dataset_version record data specifying what to update
        where
            dataset_version filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned dataset_version model

        Returns
        -------
        prisma.models.dataset_version
            The updated dataset_version record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        dataset_version = await dataset_version.prisma().update(
            where={
                'id': 1775811865,
            },
            data={
                # data to update the dataset_version record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.dataset_versionWhereUniqueInput,
        data: types.dataset_versionUpsertInput,
        include: Optional[types.dataset_versionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            dataset_version filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned dataset_version model

        Returns
        -------
        prisma.models.dataset_version
            The created or updated dataset_version record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset_version = await dataset_version.prisma().upsert(
            where={
                'id': 893145566,
            },
            data={
                'create': {
                    'id': 893145566,
                    'data_identity_id': 'beeifcbebf',
                    'datasetId': 1628650740,
                    'data_branchId': 1249606685,
                },
                'update': {
                    'data_identity_id': 'beeifcbebf',
                    'datasetId': 1628650740,
                    'data_branchId': 1249606685,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.dataset_versionUpdateManyMutationInput,
        where: types.dataset_versionWhereInput,
    ) -> int:
        """Update multiple dataset_version records

        Parameters
        ----------
        data
            dataset_version data to update the selected dataset_version records to
        where
            Filter to select the dataset_version records to update

        Returns
        -------
        int
            The total number of dataset_version records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all dataset_version records
        total = await dataset_version.prisma().update_many(
            data={
                'id': 995405759
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.dataset_versionWhereInput] = None,
        cursor: Optional[types.dataset_versionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of dataset_version records present in the database

        Parameters
        ----------
        select
            Select the dataset_version fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            dataset_version filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.dataset_versionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await dataset_version.prisma().count()

        # results: prisma.types.dataset_versionCountAggregateOutput
        results = await dataset_version.prisma().count(
            select={
                '_all': True,
                'data_identity_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.dataset_versionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.dataset_versionWhereInput] = None,
        cursor: Optional[types.dataset_versionWhereUniqueInput] = None,
    ) -> types.dataset_versionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.dataset_versionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.dataset_versionWhereInput] = None,
        cursor: Optional[types.dataset_versionWhereUniqueInput] = None,
    ) -> Union[int, types.dataset_versionCountAggregateOutput]:
        """Count the number of dataset_version records present in the database

        Parameters
        ----------
        select
            Select the dataset_version fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            dataset_version filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.dataset_versionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await dataset_version.prisma().count()

        # results: prisma.types.dataset_versionCountAggregateOutput
        results = await dataset_version.prisma().count(
            select={
                '_all': True,
                'data_identity_date': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.dataset_versionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.dataset_versionWhereInput] = None
    ) -> int:
        """Delete multiple dataset_version records.

        Parameters
        ----------
        where
            Optional dataset_version filter to find the records to be deleted

        Returns
        -------
        int
            The total number of dataset_version records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all dataset_version records
        total = await dataset_version.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.dataset_versionScalarFieldKeysT'],
        *,
        where: Optional['types.dataset_versionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.dataset_versionAvgAggregateInput'] = None,
        sum: Optional['types.dataset_versionSumAggregateInput'] = None,
        min: Optional['types.dataset_versionMinAggregateInput'] = None,
        max: Optional['types.dataset_versionMaxAggregateInput'] = None,
        having: Optional['types.dataset_versionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.dataset_versionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.dataset_versionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.dataset_versionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.dataset_versionGroupByOutput']:
        """Group dataset_version records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar dataset_version fields to group records by
        where
            dataset_version filter to select records
        take
            Limit the maximum number of dataset_version records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.dataset_versionGroupByOutput]
            A list of dictionaries representing the dataset_version record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group dataset_version records by datasetId values
        # and count how many records are in each group
        results = await dataset_version.prisma().group_by(
            ['datasetId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class data_branchActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.data_branch]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await data_branch.prisma().query_raw(
            'SELECT * FROM data_branch WHERE id = ?',
            2102736524,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.data_branch
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await data_branch.prisma().query_first(
            'SELECT * FROM data_branch WHERE full_branch_name = ?',
            'chbfcacbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.data_branchCreateInput,
        include: Optional[types.data_branchInclude] = None
    ) -> _PrismaModelT:
        """Create a new data_branch record.

        Parameters
        ----------
        data
            data_branch record data
        include
            Specifies which relations should be loaded on the returned data_branch model

        Returns
        -------
        prisma.models.data_branch
            The created data_branch record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a data_branch record from just the required fields
        data_branch = await data_branch.prisma().create(
            data={
                # data to create a data_branch record
                'full_branch_name': 'efggddide',
                'sanitized_branch_name': 'caficfigfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.data_branchCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple data_branch records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of data_branch record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await data_branch.prisma().create_many(
            data=[
                {
                    # data to create a data_branch record
                    'full_branch_name': 'bfidgijfjc',
                    'sanitized_branch_name': 'ihieecagf',
                },
                {
                    # data to create a data_branch record
                    'full_branch_name': 'bghfciaafe',
                    'sanitized_branch_name': 'bgchfhgceh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.data_branchWhereUniqueInput,
        include: Optional[types.data_branchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single data_branch record.

        Parameters
        ----------
        where
            data_branch filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned data_branch model

        Returns
        -------
        prisma.models.data_branch
            The deleted data_branch record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        data_branch = await data_branch.prisma().delete(
            where={
                'id': 2054802212,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.data_branchWhereUniqueInput,
        include: Optional[types.data_branchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique data_branch record.

        Parameters
        ----------
        where
            data_branch filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned data_branch model

        Returns
        -------
        prisma.models.data_branch
            The found data_branch record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        data_branch = await data_branch.prisma().find_unique(
            where={
                'id': 60335757,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.data_branchWhereUniqueInput,
        include: Optional[types.data_branchInclude] = None
    ) -> _PrismaModelT:
        """Find a unique data_branch record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            data_branch filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned data_branch model

        Returns
        -------
        prisma.models.data_branch
            The found data_branch record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        data_branch = await data_branch.prisma().find_unique_or_raise(
            where={
                'id': 684462146,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.data_branchWhereInput] = None,
        cursor: Optional[types.data_branchWhereUniqueInput] = None,
        include: Optional[types.data_branchInclude] = None,
        order: Optional[Union[types.data_branchOrderByInput, List[types.data_branchOrderByInput]]] = None,
        distinct: Optional[List[types.data_branchScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple data_branch records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of data_branch records returned
        skip
            Ignore the first N results
        where
            data_branch filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned data_branch model
        order
            Order the returned data_branch records by any field
        distinct
            Filter data_branch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.data_branch]
            The list of all data_branch records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 data_branch records
        data_branchs = await data_branch.prisma().find_many(take=10)

        # find the first 5 data_branch records ordered by the sanitized_branch_name field
        data_branchs = await data_branch.prisma().find_many(
            take=5,
            order={
                'sanitized_branch_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.data_branchWhereInput] = None,
        cursor: Optional[types.data_branchWhereUniqueInput] = None,
        include: Optional[types.data_branchInclude] = None,
        order: Optional[Union[types.data_branchOrderByInput, List[types.data_branchOrderByInput]]] = None,
        distinct: Optional[List[types.data_branchScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single data_branch record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            data_branch filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned data_branch model
        order
            Order the returned data_branch records by any field
        distinct
            Filter data_branch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.data_branch
            The first data_branch record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second data_branch record ordered by the id field
        data_branch = await data_branch.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.data_branchWhereInput] = None,
        cursor: Optional[types.data_branchWhereUniqueInput] = None,
        include: Optional[types.data_branchInclude] = None,
        order: Optional[Union[types.data_branchOrderByInput, List[types.data_branchOrderByInput]]] = None,
        distinct: Optional[List[types.data_branchScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single data_branch record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            data_branch filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned data_branch model
        order
            Order the returned data_branch records by any field
        distinct
            Filter data_branch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.data_branch
            The first data_branch record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second data_branch record ordered by the full_branch_name field
        data_branch = await data_branch.prisma().find_first_or_raise(
            skip=1,
            order={
                'full_branch_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.data_branchUpdateInput,
        where: types.data_branchWhereUniqueInput,
        include: Optional[types.data_branchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single data_branch record.

        Parameters
        ----------
        data
            data_branch record data specifying what to update
        where
            data_branch filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned data_branch model

        Returns
        -------
        prisma.models.data_branch
            The updated data_branch record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        data_branch = await data_branch.prisma().update(
            where={
                'id': 1625503827,
            },
            data={
                # data to update the data_branch record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.data_branchWhereUniqueInput,
        data: types.data_branchUpsertInput,
        include: Optional[types.data_branchInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            data_branch filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned data_branch model

        Returns
        -------
        prisma.models.data_branch
            The created or updated data_branch record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        data_branch = await data_branch.prisma().upsert(
            where={
                'id': 521827728,
            },
            data={
                'create': {
                    'id': 521827728,
                    'full_branch_name': 'bghfciaafe',
                    'sanitized_branch_name': 'bgchfhgceh',
                },
                'update': {
                    'full_branch_name': 'bghfciaafe',
                    'sanitized_branch_name': 'bgchfhgceh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.data_branchUpdateManyMutationInput,
        where: types.data_branchWhereInput,
    ) -> int:
        """Update multiple data_branch records

        Parameters
        ----------
        data
            data_branch data to update the selected data_branch records to
        where
            Filter to select the data_branch records to update

        Returns
        -------
        int
            The total number of data_branch records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all data_branch records
        total = await data_branch.prisma().update_many(
            data={
                'sanitized_branch_name': 'bcggadccgf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.data_branchWhereInput] = None,
        cursor: Optional[types.data_branchWhereUniqueInput] = None,
    ) -> int:
        """Count the number of data_branch records present in the database

        Parameters
        ----------
        select
            Select the data_branch fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            data_branch filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.data_branchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await data_branch.prisma().count()

        # results: prisma.types.data_branchCountAggregateOutput
        results = await data_branch.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.data_branchCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.data_branchWhereInput] = None,
        cursor: Optional[types.data_branchWhereUniqueInput] = None,
    ) -> types.data_branchCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.data_branchCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.data_branchWhereInput] = None,
        cursor: Optional[types.data_branchWhereUniqueInput] = None,
    ) -> Union[int, types.data_branchCountAggregateOutput]:
        """Count the number of data_branch records present in the database

        Parameters
        ----------
        select
            Select the data_branch fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            data_branch filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.data_branchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await data_branch.prisma().count()

        # results: prisma.types.data_branchCountAggregateOutput
        results = await data_branch.prisma().count(
            select={
                '_all': True,
                'full_branch_name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.data_branchCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.data_branchWhereInput] = None
    ) -> int:
        """Delete multiple data_branch records.

        Parameters
        ----------
        where
            Optional data_branch filter to find the records to be deleted

        Returns
        -------
        int
            The total number of data_branch records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all data_branch records
        total = await data_branch.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.data_branchScalarFieldKeysT'],
        *,
        where: Optional['types.data_branchWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.data_branchAvgAggregateInput'] = None,
        sum: Optional['types.data_branchSumAggregateInput'] = None,
        min: Optional['types.data_branchMinAggregateInput'] = None,
        max: Optional['types.data_branchMaxAggregateInput'] = None,
        having: Optional['types.data_branchScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.data_branchCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.data_branchScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.data_branchScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.data_branchGroupByOutput']:
        """Group data_branch records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar data_branch fields to group records by
        where
            data_branch filter to select records
        take
            Limit the maximum number of data_branch records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.data_branchGroupByOutput]
            A list of dictionaries representing the data_branch record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group data_branch records by sanitized_branch_name values
        # and count how many records are in each group
        results = await data_branch.prisma().group_by(
            ['sanitized_branch_name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models